package moe.lymia.sbt

import sbt._
import Keys._
import java.net.URL
import java.io._

import play.api.libs.json._
import LWJGLSupport._
import forge._
import forge.asm._
import forge.mapping._

import language._

object ForgePlugin extends Plugin {
  object forge { 
    // User setting keys
    val mcBaseVersion = SettingKey[String]("forge-minecraft-base-version",
      "The base version of Minecraft. (e.g. 1.12 for 1.12.2. This is the version used to download the MCP mapping.")
    val mcVersion     = SettingKey[String]("forge-minecraft-version",
      "The version of Minecraft to build against.")
    val version       = SettingKey[String]("forge-version",
      "THe version of Minecraft Forge to build against.")
    val fullVersion   = SettingKey[String]("forge-full-version",
      "The Minecraft Forge version number combined with the Minecraft version number.")

    val mappings      = SettingKey[String]("forge-mappings",
      "Mapping from SRG names to MCP names to use")

    val cacheRoot     = SettingKey[File]("forge-cache-root")

    val buildDir      = SettingKey[File]("forge-build-dir",
      "Directory used to store temporary build files used by sbt-forge")
    val forgeDir      = SettingKey[File]("forge-forge-dir",
      "Directory used to store files specific to a forge version")

    val ltCacheDir    = SettingKey[File]("forge-lt-dir",
      "Directory used to store persistant files generated by sbt-forge")
    val dlCacheDir    = SettingKey[File]("forge-download-dir",
      "Directory used to store files downloaded by sbt-forge")
    val versionsDir   = SettingKey[File]("forge-versions-dir",
      "Directory used to store Minecraft version metainfo by sbt-forge ")
    val assetsDir     = SettingKey[File]("forge-assets-dir",
      "Directory used to store Minecraft assets by sbt-forge ")
    val authCacheDir  = SettingKey[File]("forge-auth-cache-dir",
      "Directory used to store access tokens by sbt-forge ")

    val runDir        = SettingKey[File]("forge-run-dir",
      "Directory used at runtime by Minecraft")

    val cleanLtCache  = SettingKey[Boolean]("forge-clean-download-cache",
      "If set, sbt clean will erase the long term cache directory, containing downloads and access tokens")
    val cleanRunDir   = SettingKey[Boolean]("forge-clean-run-dir",
      "If set, sbt clean will erase the runtime directory, containing Minecraft configuration and saves")

    // Debug keys
    val debugDir          = SettingKey[File]("forge-debug-dir",
      "Directory used to store debug files dumped by sbt-forge")
    val debugDumpMappings = SettingKey[Boolean]("forge-debug-dump-mappings",
      "If set, sbt-forge will dump the temporary mappings used to actually remap .jar files")

    // URL locations
    val clientDownloadUrl    = TaskKey[String]("forge-client-download-url",
      "Download URL for the Minecraft client binary")
    val serverDownloadUrl    = TaskKey[String]("forge-server-download-url",
      "Download URL for the Minecraft server binary")
    val universalDownloadUrl = TaskKey[String]("forge-universal-download-url",
      "Download URL for the Forge binary")
    val userdevDownloadUrl   = TaskKey[String]("forge-userdev-download-url",
      "Download URL for the Userdev archive")
    val mappingDownloadUrl   = TaskKey[String]("forge-mapping-url",
      "URL to download MCP mappings from")

    // Download needed files
    val clientJar      = TaskKey[File]("forge-client-jar",
      "Location of the client jar. By default, downloads from Minecraft's CDN")
    val serverJar      = TaskKey[File]("forge-server-jar",
      "Location of the server jar. By default, downloads from Minecraft's CDN")
    val universalJar   = TaskKey[File]("forge-universal-jar", 
      "Location of the Forge universal jar. By default, downloads from Forge's website")
    val userdevArchive = TaskKey[File]("forge-userdev-archive", 
      "Location of the Forge userdev archive. By default, downloads from Forge's website")
    val mappingArchive = TaskKey[File]("forge-mapping-archive",
      "Location of the MCP mapping archive. By default, downloads from the MCPBot website")

    // Extract files needed by later steps.
    val dependenciesJson = TaskKey[File]("forge-dependencies-json",
      "Location of the .json file declaring Minecraft's dependencies. "+
      "By default, extracts dev.json from the userdev archive")
    val binpatches       = TaskKey[File]("forge-binpatches",
      "Binary patches to patch Minecraft classes with.")
    val forgeClasses     = TaskKey[File]("forge-classes",
      "Classes added by Minecraft Forge.")
    val mergeConfig      = TaskKey[File]("forge-merge-config",
      "Configuration for merging the client and server jars. "+
      "By default, extracts Forge's merge configuration from the userdev archive")
    val srgFile          = TaskKey[File]("forge-srg-file",
      "The .srg file used for notch->SRG deobf. "+
      "By default, extracts packaged.srg from the userdev archive")
    val exceptorJson     = TaskKey[File]("forge-exceptor-json",
      "The .json file used to restore inner/outer class attributes to classes. "+
      "By default, extracts exceptor.json from the userdev archive")
    val excFile          = TaskKey[File]("forge-exc-file",
      "The .exc file used to restore exception data, add __OBFID fields, and constructor parameter names to classes. "+
      "By default, extracts packaged.json from the userdev archive")

    // Load forge's dependency .json file
    val excludedOrganizations    = SettingKey[Set[String]]("forge-excluded-organizations",
      "Organizations excluded from dependency autoloading")
    val loadDependenciesFromJson = TaskKey[Seq[ModuleID]]("forge-load-dependencies",
      "Loads Forge's dependencies from dev.json")

    // Patch and merge client .jars
    val serverDepPrefixes = TaskKey[Seq[String]]("forge-server-dep-prefixes",
      "A list of packages in the Minecraft server .jar that originate from dependencies, not Minecraft itself.")
    val patchedServerJar  = TaskKey[File]("forge-patched-server-jar",
      "Patched Minecraft server binary")
    val patchedClientJar  = TaskKey[File]("forge-patched-client-jar",
      "Patched Minecraft client binary")
    val mergedJar         = TaskKey[File]("forge-merged-jar",
      "Merged Minecraft binary")

    // Deobf merged .jar to SRG names
    val accessTransformers = TaskKey[Seq[File]]("forge-access-transformers",
      "List of access transformers to be applied to the Forge binary")
    val mergedForgeBinary  = TaskKey[File]("forge-merged-forge-binary",
      "Deobfs and merges the Minecraft binary and the Minecraft Forge binary to SRG names")

    // Remap .jar files from SRG names to MCP names
    val mappingCache = TaskKey[File]("forge-mapping-cache",
      "Cached mapping generated from .csv files")
    val forgeBinary  = TaskKey[File]("forge-binary",
      "Forge binary remapped to MCP names")

    // Run Minecraft
    val runOptions     = TaskKey[ForkOptions]("forge-run-options",
      "Fork options for running Minecraft")
    val prepareRunDir  = TaskKey[Unit]("forge-prepare-run-dir",
      "Prepares the run directory for Minecraft")
    val downloadAssets = TaskKey[Unit]("forge-download-assets",
      "Downloads assets for the current Minecraft version")
    val runClient      = InputKey[Unit]("run-client", "Runs the Minecraft client.")
    val runServer      = InputKey[Unit]("run-server", "Runs the Minecraft server")

    // Clean all
    val cleanCache    = TaskKey[Unit]("clean-cache",
      "Cleans sbt-forge's long term cache")
  }

  object forgeHelpers {
    def defaultDownloadUrl(section: String) =
      forge.fullVersion map { ver =>
        s"http://files.minecraftforge.net/maven/net/minecraftforge/forge/$ver/forge-$ver-$section.jar"
      }

    def copyUrl(target: File, source: String, log: Logger, verb: String) = {
      if(!target.exists) {
        forgeHelpers synchronized {
          if(!target.getParentFile.exists)
            if(!target.getParentFile.mkdirs())
              sys.error(s"Failed to create parent directory of $target")
        }
        log.info(s"$verb $source to $target...")
        new URL(source) #> target !!
      }
      target
    }

    def jarFileUrl(jar: File, file: String) =
      s"jar:${jar.toURI.toURL}!/$file"

    // TODO: Add dependency checking
    def cachedFile[T](outFile: File)(task: File => T) = {
      if(!outFile.exists) try {
        task(outFile)
      } catch {
        case t: Throwable =>
          if(outFile.exists) outFile.delete()
          throw t
      }
      outFile
    }
    def patchJarTask(task: TaskKey[File],
                     input: TaskKey[File], outputName: String, patchSection: String) =
      task := cachedFile(forge.forgeDir.value / outputName) { outFile =>
        val patchSet = BinPatch.readPatchSet(forge.binpatches.value, patchSection)
        BinPatch.patchJar(input.value, outFile, patchSet, streams.value.log)
      }

    def extractTask(task: TaskKey[File], urlSource: TaskKey[File], sourceName: String, outputName: String, targetDir: SettingKey[File]) =
      task := copyUrl(targetDir.value / outputName,
                      jarFileUrl(urlSource.value, sourceName), streams.value.log, "Extracting")
    def downloadTask(task: TaskKey[File], versionKey: SettingKey[String], urlSource: TaskKey[String],
                     outputName: String, ext: String) =
      task := copyUrl(forge.dlCacheDir.value / s"$outputName-${versionKey.value}$ext",
                      urlSource.value, streams.value.log, "Downloading")

    val mappingRegex = "([^_]+)_(.+)".r
    def splitMapping(s: String) = s match {
      case mappingRegex(channel, version) => (channel, version)
      case _ => sys.error(s"Could not parse mapping channel name: $s")
    }

    def dumpDebugMapping(debugDir: File, map: ForgeMapping, name: String) = {
      if(!debugDir.exists) debugDir.mkdirs()
      dumpMapping(new FileOutputStream(debugDir / name), map)
    }

    def ln(source: File, target: File) {
      import java.nio.file._
      Files.createSymbolicLink(Paths.get(target.getCanonicalPath),
                               Paths.get(source.getCanonicalPath))
    }
  }
  import forgeHelpers._

  lazy val forgeSettingsBase: Seq[Setting[_]] = lwjglSettings ++ Seq(
    forge.fullVersion  := forge.mcVersion.value + "-" + forge.version.value,

    forge.cacheRoot    := target.value / "sbt-forge-cache",

    forge.buildDir     := forge.cacheRoot.value / "build",
    forge.forgeDir     := forge.buildDir.value / ("forge-"+forge.fullVersion.value),

    forge.ltCacheDir   := forge.cacheRoot.value / "persistent",
    forge.dlCacheDir   := forge.ltCacheDir.value / "downloads",
    forge.assetsDir    := forge.ltCacheDir.value / "assets",
    forge.versionsDir  := forge.ltCacheDir.value / "versions",
    forge.authCacheDir := forge.ltCacheDir.value / "tokens",

    forge.runDir       := baseDirectory.value / "run",

    forge.cleanLtCache := false,
    forge.cleanRunDir  := false,

    forge.debugDir          := forge.buildDir.value / "debug",
    forge.debugDumpMappings := false,

    // Download needed files
    forge.clientDownloadUrl := VersionManager.getClientDownloadUrl(forge.versionsDir.value, forge.mcVersion.value),
    forge.serverDownloadUrl := VersionManager.getServerDownloadUrl(forge.versionsDir.value, forge.mcVersion.value),
    forge.universalDownloadUrl <<= defaultDownloadUrl("universal"),
    forge.userdevDownloadUrl   <<= defaultDownloadUrl("userdev"),
    forge.mappingDownloadUrl    := {
      val (ch, version) = splitMapping(forge.mappings.value)
      val ver = version + "-" + forge.mcBaseVersion.value
      s"http://export.mcpbot.bspk.rs/mcp_$ch/$ver/mcp_$ch-$ver.zip"
    },

    downloadTask(forge.clientJar     , forge.mcVersion  , forge.clientDownloadUrl   , "minecraft_client", ".jar"),
    downloadTask(forge.serverJar     , forge.mcVersion  , forge.serverDownloadUrl   , "minecraft_server", ".jar"),
    downloadTask(forge.universalJar  , forge.fullVersion, forge.universalDownloadUrl, "forge_universal" , ".jar"),
    downloadTask(forge.userdevArchive, forge.fullVersion, forge.userdevDownloadUrl  , "forge_userdev"   , ".jar"),
    downloadTask(forge.mappingArchive, forge.mappings   , forge.mappingDownloadUrl  , "mcp_mappings"    , ".zip"),

    // Extract files used in later processes
    extractTask(forge.mergeConfig     , forge.userdevArchive, "conf/mcp_merge.cfg"  , "mcp_merge.cfg"       , forge.forgeDir),
    extractTask(forge.srgFile         , forge.userdevArchive, "conf/packaged.srg"   , "packaged.srg"        , forge.forgeDir),
    extractTask(forge.exceptorJson    , forge.userdevArchive, "conf/exceptor.json"  , "exceptor.json"       , forge.forgeDir),
    extractTask(forge.excFile         , forge.userdevArchive, "conf/packaged.exc"   , "packaged.exc"        , forge.forgeDir),
    extractTask(forge.dependenciesJson, forge.userdevArchive, "dev.json"            , "dev.json"            , forge.forgeDir),

    // Set up dependency resolution
    resolvers += "forge" at "http://files.minecraftforge.net/maven",
    resolvers += "minecraft" at "https://libraries.minecraft.net/",
    resolvers += Resolver.sonatypeRepo("releases"),
    resolvers += Resolver.sonatypeRepo("snapshots"),

    forge.loadDependenciesFromJson :=
      (Json.parse(IO.read(forge.dependenciesJson.value)) \ "libraries").as[Seq[JsObject]].map { elem =>
        val Array(org, project, version) = (elem \ "name").as[String].split(":")
        org % project % version
      }.filter(x => !forge.excludedOrganizations.value.contains(x.organization)),
    // TODO: Add references to the repo versions of scala libraries.
    allDependencies <++= forge.loadDependenciesFromJson,

    // Patch and merge client and server jars.
    extractTask(forge.binpatches, forge.universalJar,
                "binpatches.pack.lzma", "binpatches.pack.lzma", forge.forgeDir),
    extractTask(forge.forgeClasses, forge.userdevArchive,
                "classes.jar", "classes.jar", forge.forgeDir),
    patchJarTask(forge.patchedClientJar, forge.clientJar, "minecraft_client_patched.jar", "client"),
    patchJarTask(forge.patchedServerJar, forge.serverJar, "minecraft_server_patched.jar", "server"),
    forge.mergedJar := {
      val log = streams.value.log
      cachedFile(forge.forgeDir.value / "minecraft_merged.jar") { outFile =>
        log.info("Merging client and server binaries to "+outFile)
        writeJarFile(
          Merger.merge(forge.patchedClientJar.value, forge.patchedServerJar.value,
                       forge.forgeClasses.value, forge.serverDepPrefixes.value, log),
          new FileOutputStream(outFile)
        )
      }
    },

    // Process jars to merged SRG Forge binary
    forge.accessTransformers := Seq(
      copyUrl(forge.forgeDir.value / "forge_at.cfg", jarFileUrl(forge.userdevArchive.value, "src/main/resources/forge_at.cfg"),
              streams.value.log, "Extracting"),
      copyUrl(forge.forgeDir.value / "fml_at.cfg"  , jarFileUrl(forge.userdevArchive.value, "src/main/resources/fml_at.cfg"  ),
              streams.value.log, "Extracting")
    ),
    forge.mergedForgeBinary := {
      val log = streams.value.log
      cachedFile(forge.forgeDir.value / "forgeBin_srg.jar") { outFile =>
        val classpath = (managedClasspath in Compile).value.map(_.data)
        val minecraftNotch = loadJarFile(new FileInputStream(forge.mergedJar.value))
        val forgeNotch = loadJarFile(new FileInputStream(forge.universalJar.value))
        val map = mappingFromSrgFile(minecraftNotch, IO.readLines(forge.srgFile.value), log)

        log.info("Adding mappings for Minecraft Forge inner classes")
        Renamer.findRemappableInnerClass(minecraftNotch.classes ++ forgeNotch.classes, map, log)

        log.info("Deobfing merged Minecraft binary to SRG names...")
        val (tmpmap_mc   , minecraftSrg) = Renamer.applyMapping(minecraftNotch, Seq(forge.universalJar.value), classpath, map, log)
        if(forge.debugDumpMappings.value) dumpDebugMapping(forge.debugDir.value, tmpmap_mc, "tmpmap_mc.sfmap")

        log.info("Restoring class attributes...")
        Exceptor.applyExceptorJson(minecraftSrg, IO.read(forge.exceptorJson.value), log)
        Exceptor.applyExcFile(minecraftSrg, new FileInputStream(forge.excFile.value), log)

        log.info("Deobfing Forge binary to SRG names...")
        val (tmpmap_forge, forgeSrg) = Renamer.applyMapping(forgeNotch, Seq(forge.mergedJar.value), classpath, map, log)
        if(forge.debugDumpMappings.value) dumpDebugMapping(forge.debugDir.value, tmpmap_forge, "tmpmap_forge.sfmap")

        log.info("Merging Forge binary and Minecraft binary...")
        val mergedBin = Merger.addForgeClasses(minecraftSrg, forgeSrg, log)

        log.info("Adding SRG parameter names...")
        Exceptor.addDefaultParameterNames(mergedBin)
        log.info("Stripping synthetic modifiers...")
        Exceptor.stripSynthetic(mergedBin)

        log.info("Removing patch data...")
        mergedBin.resources.remove("binpatches.pack.lzma")

        log.info("Running access transformers...")
        forge.accessTransformers.value.foreach { at =>
          log.info(s"  - ${at.getName}")
          AccessTransformer.applyAccessTransformers(mergedBin, IO.readLines(at), log)
        }

        log.info(s"Writing merged Forge binary to $outFile")
        writeJarFile(mergedBin, new FileOutputStream(outFile))
      }
    },

    forge.mappingCache := {
      val log = streams.value.log
      cachedFile(forge.forgeDir.value / s"srg2mcp-${forge.mappings.value}.sfmap") { outFile =>
        log.info(s"Generating $outFile...")
        val fieldsFile  = IO.readLinesURL(new URL(jarFileUrl(forge.mappingArchive.value, "fields.csv" ))).tail
        val methodsFile = IO.readLinesURL(new URL(jarFileUrl(forge.mappingArchive.value, "methods.csv"))).tail

        val map = mappingFromConfFiles(loadJarFile(new FileInputStream(forge.mergedForgeBinary.value)), fieldsFile, methodsFile)
        dumpMapping(new FileOutputStream(outFile), map)
      }
    },
    forge.forgeBinary := {
      val log = streams.value.log
      cachedFile(forge.forgeDir.value / (s"forgeBin-${forge.fullVersion.value}-${forge.mappings.value}.jar")) { outFile =>
        log.info(s"Deobfing Forge binary to MCP names at $outFile")
        val classpath = (managedClasspath in Compile).value.map(_.data)
        val map = readMapping(IO.readLines(forge.mappingCache.value))
        val (tmpmap_mcp, jar) = Renamer.applyMapping(loadJarFile(new FileInputStream(forge.mergedForgeBinary.value)), Seq(), classpath, map, log)
        if(forge.debugDumpMappings.value) dumpDebugMapping(forge.debugDir.value, tmpmap_mcp, "tmpmap_mcp.sfmap")

        log.info("Mapping parameter names...")
        val paramsFile = IO.readLinesURL(new URL(jarFileUrl(forge.mappingArchive.value, "params.csv"))).tail
        Renamer.mapParams(jar, paramsFile)

        writeJarFile(jar, new FileOutputStream(outFile))
      }
    },
    fullClasspath in Compile <+= forge.forgeBinary,

    forge.runOptions := ForkOptions(
      connectInput = true,
      outputStrategy = Some(StdoutOutput),
      runJVMOptions = javaOptions.value ++ Seq(
        "-Dfml.ignoreInvalidMinecraftCertificates=true"
      ),
      workingDirectory = Some(forge.runDir.value)
    ),
    forge.prepareRunDir := {
      forge.runDir.value.mkdirs()

      val modDir = forge.runDir.value / "mods"
      val artifact = (artifactPath in (Compile, packageBin)).value

      IO.delete(modDir)
      modDir.mkdirs()
      ln(artifact, modDir / artifact.getName)
    },
    forge.downloadAssets :=
      VersionManager.prepareAssets(forge.assetsDir.value, forge.versionsDir.value, forge.mcVersion.value,
                                   streams.value.log),
    forge.runClient in Runtime := {
      val runner = new ForkRun(forge.runOptions.value)
      val params = (Json.parse(IO.read(forge.dependenciesJson.value)) \ "minecraftArguments").as[String].split(" ") ++ Seq(
        "--gameDir", forge.runDir.value.getCanonicalPath,
        "--assetsDir", forge.assetsDir.value.getCanonicalPath,
        "--assetIndex", forge.mcVersion.value
      )

      val args: Seq[String] = Def.spaceDelimited().parsed
      val authConfig =
        if(args.isEmpty) Seq(
          "--username", "ForgeDevName",
          "--accessToken", "FML",
          "--userProperties", "{}"
        ) else AuthManager.authenticate(forge.authCacheDir.value, args(0), streams.value.log)

      val fullConfig = params ++ authConfig
      val censoredConfig = fullConfig.zip("" +: fullConfig).map { t =>
        if(t._2 == "--accessToken") "***"
        else "\""+t._1+"\""
      }.mkString(", ")
      streams.value.log.info(s"Launching with parameters: [$censoredConfig]")

      toError(runner.run(
        "net.minecraft.launchwrapper.Launch",
        (dependencyClasspath in Runtime).value.map(_.data) :+ forge.forgeBinary.value,
        fullConfig,
        streams.value.log
      ))
    },
    forge.runServer in Runtime := {
      val runner = new ForkRun(forge.runOptions.value)
      toError(runner.run(
        "cpw.mods.fml.relauncher.ServerLaunchWrapper",
        (dependencyClasspath in Runtime).value.map(_.data) :+ forge.forgeBinary.value,
        Seq(),
        streams.value.log
      ))
    },

    forge.runClient in Runtime <<= (forge.runClient in Runtime) dependsOn
      (Keys.`package` in Compile, forge.prepareRunDir, lwjgl.copyNatives, forge.downloadAssets),
    forge.runServer in Runtime <<= (forge.runServer in Runtime) dependsOn
      (Keys.`package` in Compile, forge.prepareRunDir),

    forge.cleanCache := Defaults.doClean(Seq(forge.cacheRoot.value), Seq()),
    cleanKeepFiles ++= (if(forge.cleanLtCache.value) Seq() else Seq(forge.ltCacheDir.value)),
    cleanFiles ++= (if(forge.cleanRunDir.value) Seq(forge.cacheRoot.value, forge.runDir.value)
                    else                        Seq(forge.cacheRoot.value))
  )
  lazy val forgeSettings_1_12 = forgeSettingsBase ++ Seq(
    forge.mcBaseVersion := "1.12",
    forge.mcVersion     := "1.12.2",
    forge.version       := "14.23.4.2759",
    forge.mappings      := "stable_39",
    scalaVersion        := "2.11.1",

    forge.excludedOrganizations := Set("org.scala-lang", "org.scala-lang.plugins", "org.lwjgl.lwjgl"),
    forge.serverDepPrefixes := Seq(
      "org/bouncycastle/", "org/apache/", "com/google/", "com/mojang/authlib/", "com/mojang/util/",
      "gnu/trove/", "io/netty/", "javax/annotation/", "argo/", "it/"
    )
  )
}
