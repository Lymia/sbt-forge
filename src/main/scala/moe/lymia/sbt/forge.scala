package moe.lymia.sbt

import java.io._
import java.net.URL

import moe.lymia.forge._
import moe.lymia.forge.asm._
import moe.lymia.forge.launcher.MinecraftLauncher
import moe.lymia.forge.mapping._
import moe.lymia.forge.Utils._
import moe.lymia.forge.build.AccessTransformer
import moe.lymia.sbt.LWJGLPlugin.autoImport._
import play.api.libs.json._
import org.apache.commons.io.FileUtils
import sbt.Keys._
import sbt.{Def, _}

// TODO: Remove mcBaseVersion, and instead load the MCP versions.json file.
// TODO: Put all the default URLs, etc into its own file.
// TODO: Kill LVTs to get rid of Mojang's snowmen.

// TODO: When sbt's devs get their heads out of their rear ends, and revert the change to `.value` in lambdas, put
//       them back where they belong.

object BaseForgePlugin extends AutoPlugin {
  object autoImport {
    // Configurations
    val ForgeBuild = config("ForgeBuild") extend Default describedAs
      "A configuration used to build Forge binaries."
    val ForgeRun = config("ForgeRun") extend Default describedAs
      "A configuration used to run Forge."

    // Task/setting/input keys
    object forge {
      // User setting keys
      val mcBaseVersion = SettingKey[String]("forge-minecraft-base-version",
        "The base version of Minecraft. (e.g. 1.12 for 1.12.2. This is the version used to download the MCP mapping.")
      val mcVersion     = SettingKey[String]("forge-minecraft-version",
        "The version of Minecraft to build against.")
      val version       = SettingKey[String]("forge-version",
        "THe version of Minecraft Forge to build against.")
      val fullVersion   = SettingKey[String]("forge-full-version",
        "The Minecraft Forge version number combined with the Minecraft version number.")
      val scalaVersion  = SettingKey[String]("forge-scala-version",
        "The version of Scala that Minecraft Forge bundles.")

      val mappings      = SettingKey[String]("forge-mappings",
        "Mapping from SRG names to MCP names to use")

      val cacheRoot     = SettingKey[File]("forge-cache-root")

      val buildDir      = SettingKey[File]("forge-build-dir",
        "Directory used to store temporary build files used by sbt-forge")
      val forgeDir      = SettingKey[File]("forge-forge-dir",
        "Directory used to store files specific to a forge version")

      val ltCacheDir    = SettingKey[File]("forge-lt-dir",
        "Directory used to store persistant files generated by sbt-forge")
      val dlCacheDir    = SettingKey[File]("forge-download-dir",
        "Directory used to store files downloaded by sbt-forge")
      val launcherDir   = SettingKey[File]("forge-launcher-dir",
        "Directory used by the Minecraft launcher integrated into sbt-forge ")

      val runDir        = SettingKey[File]("forge-run-dir",
        "Directory used at runtime by Minecraft")

      val cleanLtCache  = SettingKey[Boolean]("forge-clean-download-cache",
        "If set, sbt clean will erase the long term cache directory, containing downloads and access tokens")
      val cleanRunDir   = SettingKey[Boolean]("forge-clean-run-dir",
        "If set, sbt clean will erase the runtime directory, containing Minecraft configuration and saves")

      // URL locations
      val universalDownloadUrl = TaskKey[String]("forge-universal-download-url",
        "Download URL for the Forge binary")
      val userdevDownloadUrl   = TaskKey[String]("forge-userdev-download-url",
        "Download URL for the Userdev archive")
      val srgDownloadUrl       = TaskKey[String]("forge-srg-download-url",
        "Download URL for Notch -> SRG mapping archive")
      val mappingDownloadUrl   = TaskKey[String]("forge-mapping-url",
        "Download URL for the SRG->MCP mappings")

      // Download needed files
      val clientJar      = TaskKey[File]("forge-client-jar",
        "Location of the client jar. By default, downloads from Minecraft's CDN")
      val serverJar      = TaskKey[File]("forge-server-jar",
        "Location of the server jar. By default, downloads from Minecraft's CDN")
      val universalJar   = TaskKey[File]("forge-universal-jar",
        "Location of the Forge universal jar. By default, downloads from Forge's website")
      val userdevArchive = TaskKey[File]("forge-userdev-archive",
        "Location of the Forge userdev archive. By default, downloads from Forge's website")
      val srgArchive     = TaskKey[File]("forge-srg-archive",
        "Location of the MCP SRG data archive. By default, downloads from Forge's website")
      val mappingArchive = TaskKey[File]("forge-mapping-archive",
        "Location of the MCP mapping archive. By default, downloads from the MCPBot website")

      // Extract files needed by later steps.
      val dependenciesJson = TaskKey[File]("forge-dependencies-json",
        "Location of the .json file declaring Minecraft's dependencies.")
      val binpatches       = TaskKey[File]("forge-binpatches",
        "Binary patches to patch Minecraft classes with.")
      val forgeClasses     = TaskKey[File]("forge-classes",
        "Classes added by Minecraft Forge.")
      val srgFile          = TaskKey[File]("forge-srg-file",
        "The .srg file used for notch->SRG deobf.")
      val exceptorJson     = TaskKey[File]("forge-exceptor-json",
        "The .json file used to restore inner/outer class attributes to classes.")
      val excFile          = TaskKey[File]("forge-exc-file",
        "The .exc file used to restore exception data, and constructor parameter names to classes.")
      val forgeAtFile          = TaskKey[File]("forge-forge-at-file",
        "The access transformer used by Minecraft Forge itself.")

      // Load forge's dependency .json file
      val excludedOrganizations         = SettingKey[Set[String]]("forge-excluded-organizations",
        "Organizations excluded from dependency autoloading")
      val minecraftAllProvidedLibraries = TaskKey[Seq[ModuleID]]("forge-all-minecraft-provided-libraries",
        "Libraries expected to be provided from Minecraft or Forge.")
      val minecraftProvidedLibraries    = TaskKey[Seq[ModuleID]]("forge-minecraft-provided-libraries",
        "Libraries expected to be provided from Minecraft or Forge, except those specified in excludedOrganizations.")

      // Patch and merge client .jars
      val serverDepPrefixes = TaskKey[Seq[String]]("forge-server-dep-prefixes",
        "A list of packages in the Minecraft server .jar that originate from dependencies, not Minecraft itself.")
      val patchedServerJar  = TaskKey[File]("forge-patched-server-jar",
        "Patched Minecraft server binary")
      val patchedClientJar  = TaskKey[File]("forge-patched-client-jar",
        "Patched Minecraft client binary")
      val mergedJar         = TaskKey[File]("forge-merged-jar",
        "Merged Minecraft binary")

      // Deobf merged .jar to SRG names
      val accessTransformers = TaskKey[Seq[File]]("forge-access-transformers",
        "List of access transformers to be applied to the Forge binary")
      val srgForgeBinary     = TaskKey[File]("forge-srg-forge-binary",
        "Deobfs and merges the Minecraft binary and the Minecraft Forge binary to SRG names")

      // Remap .jar files from SRG names to MCP names
      val mappingCache    = TaskKey[File]("forge-mapping-cache",
        "Cached mapping generated from .csv files")
      val srgToMcpMapping = TaskKey[File]("forge-srg-to-mcp-mapping",
        "Cached SRG to MCP mapping used by Forge")
      val forgeBinary     = TaskKey[File]("forge-binary",
        "Forge binary remapped to MCP names")

      // Run Minecraft
      val runOptions   = TaskKey[ForkOptions]("forge-run-options", "Fork options for running Minecraft")
      val modClasspath = TaskKey[Seq[File]]("forge-mod-classpath", "A list of mods loaded by runClient and runServer")
      val login        = InputKey[Unit]("login", "Logs you into a Minecraft account")
      val logout       = InputKey[Unit]("logout", "Logs you out of your Minecraft account")
      val runClient    = InputKey[Unit]("run-client", "Runs the Minecraft client.")
      val runServer    = InputKey[Unit]("run-server", "Runs the Minecraft server")

      // Clean all
      val cleanCache    = TaskKey[Unit]("clean-cache",
        "Cleans sbt-forge's long term cache")
    }
  }
  import autoImport._

  object forgeHelpers {
    def defaultDownloadUrl(ver: String, section: String) =
      s"http://files.minecraftforge.net/maven/net/minecraftforge/forge/$ver/forge-$ver-$section.jar"

    def copyUrl(target: File, source: String, log: Logger, verb: String) = {
      if(!target.exists) {
        log.info(s"$verb $source to $target...")
        FileUtils.copyURLToFile(new URL(source), target)
      }
      target
    }

    def jarFileUrl(jar: File, file: String) =
      s"jar:${jar.toURI.toURL}!/$file"

    def patchJarTask(task: TaskKey[File], inputTask: TaskKey[File],
                     outputName: String, patchSection: String) =
      task := {
        val (log, binpatches, input) = (streams.value.log, forge.binpatches.value, inputTask.value)
        cachedFile(forge.forgeDir.value / outputName) { outFile =>
          val patchSet = BinPatch.readPatchSet(binpatches, patchSection)
          BinPatch.patchJar(input, outFile, patchSet, log)
        }
      }

    def extractTask(task: TaskKey[File], urlSource: TaskKey[File],
                    sourceName: String, outputName: String, targetDir: SettingKey[File]) =
      task := copyUrl(targetDir.value / outputName,
                      jarFileUrl(urlSource.value, sourceName), streams.value.log, "Extracting")
    def downloadTask(task: TaskKey[File], versionKey: SettingKey[String], urlSource: TaskKey[String],
                     outputName: String, ext: String) =
      task := copyUrl(forge.dlCacheDir.value / s"$outputName-${versionKey.value}$ext",
                      urlSource.value, streams.value.log, "Downloading")

    val mappingRegex = "([^_]+)_(.+)".r
    def splitMapping(s: String) = s match {
      case mappingRegex(channel, version) => (channel, version)
      case _ => sys.error(s"Could not parse mapping channel name: $s")
    }

    def dumpDebugMapping(debugDir: File, map: ForgeMapping, name: String) = {
      if(!debugDir.exists) debugDir.mkdirs()
      dumpMapping(new FileOutputStream(debugDir / name), map)
    }
  }
  import forgeHelpers._

  // Initialize Forge scopes
  private lazy val depsFromJar: Seq[Def.Setting[_]] = Seq(
    forge.minecraftProvidedLibraries := forge.minecraftAllProvidedLibraries.value
      .filter(x => !forge.excludedOrganizations.value.contains(x.organization)),
    allDependencies ++= forge.minecraftProvidedLibraries.value,
  )

  private lazy val forgeCommon: Seq[Def.Setting[_]] = Classpaths.configSettings ++ Classpaths.ivyBaseSettings ++ Seq(
    allDependencies := Seq(),
    allDependencies ++= lwjgl.libraries.value,

    // We don't actually have any proper products. We use Classpaths only for downloading Maven dependencies.
    products := Seq(),
    exportedProducts := Seq(),
    exportedProductsIfMissing := Seq(),
    exportedProductsNoTracking := Seq(),
    exportedProductJars := Seq(),
    exportedProductJarsIfMissing := Seq(),
    exportedProductJarsNoTracking := Seq(),

    artifactPath := forge.cacheRoot.value / "artifact_path_keep_empty",
    classDirectory := forge.cacheRoot.value / "class_directory_keep_empty",
  ) ++ depsFromJar
  private lazy val projectSettingsCommon =
    depsFromJar ++ inConfig(ForgeRun)(forgeCommon) ++ inConfig(ForgeBuild)(forgeCommon)

  override val requires = LWJGLPlugin
  override lazy val projectSettings = projectSettingsCommon ++ Seq(
    forge.fullVersion  := forge.mcVersion.value + "-" + forge.version.value,

    forge.cacheRoot    := target.value / "sbt-forge-cache",

    forge.buildDir     := forge.cacheRoot.value / "build",
    forge.forgeDir     := forge.buildDir.value / ("forge-"+forge.fullVersion.value),

    forge.ltCacheDir   := forge.cacheRoot.value / "persistent",
    forge.dlCacheDir   := forge.ltCacheDir.value / "downloads",
    forge.launcherDir  := forge.ltCacheDir.value / "launcher",

    forge.runDir       := baseDirectory.value / "run",

    forge.cleanLtCache := false,
    forge.cleanRunDir  := false,

    // Download needed files
    forge.universalDownloadUrl := defaultDownloadUrl(forge.fullVersion.value, "universal"),
    forge.userdevDownloadUrl   := defaultDownloadUrl(forge.fullVersion.value, "userdev"),
    forge.srgDownloadUrl       := {
      val mcVersion = forge.mcVersion.value
      s"http://files.minecraftforge.net/maven/de/oceanlabs/mcp/mcp/$mcVersion/mcp-$mcVersion-srg.zip"
    },
    forge.mappingDownloadUrl   := {
      val (ch, version) = splitMapping(forge.mappings.value)
      val ver = version + "-" + forge.mcBaseVersion.value
      s"http://export.mcpbot.bspk.rs/mcp_$ch/$ver/mcp_$ch-$ver.zip"
    },

    forge.clientJar :=
      MinecraftLauncher.downloadClient(forge.launcherDir.value, forge.mcVersion.value, streams.value.log),
    forge.serverJar :=
      MinecraftLauncher.downloadServer(forge.launcherDir.value, forge.mcVersion.value, streams.value.log),

    downloadTask(forge.universalJar  , forge.fullVersion  , forge.universalDownloadUrl, "forge_universal" , ".jar"),
    downloadTask(forge.userdevArchive, forge.fullVersion  , forge.userdevDownloadUrl  , "forge_userdev"   , ".jar"),
    downloadTask(forge.srgArchive    , forge.mcBaseVersion, forge.srgDownloadUrl      , "mcp_srg_data"    , ".zip"),
    downloadTask(forge.mappingArchive, forge.mappings     , forge.mappingDownloadUrl  , "mcp_mappings"    , ".zip"),

    // Extract files used in later processes
    extractTask(forge.binpatches, forge.universalJar, "binpatches.pack.lzma", "binpatches.pack.lzma", forge.forgeDir),
    extractTask(forge.forgeClasses, forge.userdevArchive, "classes.jar", "classes.jar", forge.forgeDir),

    extractTask(forge.srgFile         , forge.srgArchive    , "joined.srg"   , "joined.srg"   , forge.forgeDir),
    extractTask(forge.exceptorJson    , forge.srgArchive    , "exceptor.json", "exceptor.json", forge.forgeDir),
    extractTask(forge.excFile         , forge.srgArchive    , "joined.exc"   , "joined.exc"   , forge.forgeDir),
    extractTask(forge.dependenciesJson, forge.userdevArchive, "dev.json"     , "dev.json"     , forge.forgeDir),
    extractTask(forge.forgeAtFile     , forge.userdevArchive, "merged_at.cfg", "merged_at.cfg", forge.forgeDir),

    // Set up dependency resolution
    resolvers += "forge" at "http://files.minecraftforge.net/maven",
    resolvers += "minecraft" at "https://libraries.minecraft.net/",
    resolvers += Resolver.sonatypeRepo("releases"),
    resolvers += Resolver.sonatypeRepo("snapshots"),

    forge.minecraftAllProvidedLibraries :=
      MinecraftLauncher.getDependencies(forge.launcherDir.value, forge.mcVersion.value,
                                        Seq(forge.dependenciesJson.value), streams.value.log),

    scalaVersion := forge.scalaVersion.value,

    // Patch and merge client and server jars.
    patchJarTask(forge.patchedClientJar, forge.clientJar, "minecraft_client_patched.jar", "client"),
    patchJarTask(forge.patchedServerJar, forge.serverJar, "minecraft_server_patched.jar", "server"),
    forge.mergedJar := {
      val log = streams.value.log
      val (patchedClientJar, patchedServerJar, forgeClasses, serverDepPrefixes) =
        (forge.patchedClientJar.value, forge.patchedServerJar.value,
         forge.forgeClasses.value, forge.serverDepPrefixes.value)
      cachedFile(forge.forgeDir.value / "minecraft_merged.jar") { outFile =>
        log.info("Merging client and server binaries to "+outFile)
        writeJarFile(
          Merger.merge(patchedClientJar, patchedServerJar, forgeClasses, serverDepPrefixes, log),
          new FileOutputStream(outFile)
        )
      }
    },

    // Process jars to merged SRG Forge binary
    forge.accessTransformers := Seq(),
    forge.accessTransformers in ForgeBuild := forge.accessTransformers.value :+ forge.forgeAtFile.value,
    forge.srgForgeBinary := {
      val log = streams.value.log
      val classpath = (fullClasspath in ForgeBuild).value.map(_.data)
      val (mergedJar, universalJar) = (forge.mergedJar.value, forge.universalJar.value)
      val (srgFile, exceptorJson, excFile) =
        (forge.srgFile.value, forge.exceptorJson.value, forge.excFile.value)
      val accessTransformers = (forge.accessTransformers in ForgeBuild).value
      cachedFile(forge.forgeDir.value / "forgeBin_srg.jar") { outFile =>
        val minecraftNotch = loadJarFile(new FileInputStream(mergedJar))
        val forgeNotch = loadJarFile(new FileInputStream(universalJar))
        val map = readSrgMapping(minecraftNotch, IO.readLines(srgFile), log)

        log.info("Adding mappings for Minecraft Forge inner classes")
        Renamer.findRemappableInnerClass(minecraftNotch.classes ++ forgeNotch.classes, map, log)

        log.info("Deobfing merged Minecraft binary to SRG names...")
        val (tmpmap_mc, minecraftSrg) =
          Renamer.applyMapping(minecraftNotch, Seq(universalJar), classpath, map, log)

        log.info("Restoring class attributes...")
        Exceptor.applyExceptorJson(minecraftSrg, IO.read(exceptorJson), log)
        Exceptor.applyExcFile(minecraftSrg, new FileInputStream(excFile), log)

        log.info("Deobfing Forge binary to SRG names...")
        val (tmpmap_forge, forgeSrg) =
          Renamer.applyMapping(forgeNotch, Seq(mergedJar), classpath, map, log)

        log.info("Merging Forge binary and Minecraft binary...")
        val mergedBin = Merger.addForgeClasses(minecraftSrg, forgeSrg, log)

        log.info("Adding SRG parameter names...")
        Exceptor.addDefaultParameterNames(mergedBin)

        log.info("Stripping synthetic modifiers...")
        Exceptor.stripSynthetic(mergedBin)

        log.info("Removing patch data...")
        mergedBin.resources.remove("binpatches.pack.lzma")

        log.info("Running access transformers...")
        val transformer = AccessTransformer.parse(accessTransformers : _*)
        transformer.writeTo(new File("transformer_tmp_at.cfg"))
        val transformedBin = transformer.transformJar(mergedBin)

        log.info(s"Writing merged Forge binary to $outFile")
        writeJarFile(transformedBin, new FileOutputStream(outFile))
      }
    },

    forge.mappingCache := {
      val log = streams.value.log
      val mappingArchive = forge.mappingArchive.value
      val srgForgeBinary = forge.srgForgeBinary.value
      cachedFile(forge.forgeDir.value / s"srg2mcp-${forge.mappings.value}.sfmap") { outFile =>
        log.info(s"Generating $outFile...")
        val fieldsFile  = IO.readLinesURL(new URL(jarFileUrl(mappingArchive, "fields.csv" ))).tail
        val methodsFile = IO.readLinesURL(new URL(jarFileUrl(mappingArchive, "methods.csv"))).tail

        val map = mappingFromConfFiles(loadJarFile(new FileInputStream(srgForgeBinary)), fieldsFile, methodsFile)
        dumpMapping(new FileOutputStream(outFile), map)
      }
    },
    forge.srgToMcpMapping := {
      val log = streams.value.log
      val mappingCache = forge.mappingCache.value
      cachedFile(forge.forgeDir.value / s"srg2mcp-${forge.mappings.value}.srg") { outFile =>
        log.info(s"Generating $outFile...")
        val map = readMapping(IO.readLines(mappingCache))
        dumpSrgMapping(new FileOutputStream(outFile), map)
      }
    },
    forge.forgeBinary := {
      val log = streams.value.log
      val classpath = (fullClasspath in ForgeBuild).value.map(_.data)
      val mappingCache = forge.mappingCache.value
      val srgForgeBinary = forge.srgForgeBinary.value
      val mappingArchive = forge.mappingArchive.value
      cachedFile(forge.forgeDir.value / s"forgeBin-${forge.fullVersion.value}-${forge.mappings.value}.jar") { outFile =>
        log.info(s"Deobfing Forge binary to MCP names at $outFile")
        val map = readMapping(IO.readLines(mappingCache))
        val (tmpmap_mcp, jar) =
          Renamer.applyMapping(loadJarFile(new FileInputStream(srgForgeBinary)), Seq(), classpath, map, log)

        log.info("Mapping parameter names...")
        val paramsFile = IO.readLinesURL(new URL(jarFileUrl(mappingArchive, "params.csv"))).tail
        Renamer.mapParams(jar, paramsFile)

        writeJarFile(jar, new FileOutputStream(outFile))
      }
    },
    unmanagedClasspath in Compile += forge.forgeBinary.value,
    unmanagedClasspath in ForgeRun += forge.forgeBinary.value,

    // Launcher bindings
    forge.modClasspath := Seq(),
    forge.modClasspath += (Keys.`package` in Compile).value,

    forge.login  := MinecraftLauncher.login (forge.launcherDir.value, streams.value.log),
    forge.logout := MinecraftLauncher.logout(forge.launcherDir.value, streams.value.log),

    forge.runOptions := ForkOptions()
      .withConnectInput(true)
      .withOutputStrategy(Some(StdoutOutput))
      .withRunJVMOptions((javaOptions.value ++ Seq(
        "-Dfml.ignoreInvalidMinecraftCertificates=true",
        s"-Dnet.minecraftforge.gradle.GradleStart.srg.srg-mcp=${forge.srgToMcpMapping.value}"
      )).toVector)
      .withWorkingDirectory(forge.runDir.value),
    forge.runClient := {
      lwjgl.copyNatives.value // Discard value, use this just to... well, copy the natives
      createDirectories(forge.runDir.value)
      MinecraftLauncher.prepareModsDirectory(forge.runDir.value, forge.modClasspath.value, streams.value.log)

      val runner = new ForkRun(forge.runOptions.value)
      val forgeArgs = (Json.parse(IO.read(forge.dependenciesJson.value)) \ "minecraftArguments").as[String].split(" ")
      val launcherArgs = MinecraftLauncher.prepareClientLaunch(forge.runDir.value, forge.launcherDir.value,
                                                               forge.mcVersion.value, streams.value.log)
      runner.run(
        "net.minecraft.launchwrapper.Launch",
        (fullClasspath in ForgeRun).value.map(_.data),
        forgeArgs ++ launcherArgs,
        streams.value.log
      ).get
    },
    forge.runServer := {
      createDirectories(forge.runDir.value)
      MinecraftLauncher.prepareModsDirectory(forge.runDir.value, forge.modClasspath.value, streams.value.log)

      val runner = new ForkRun(forge.runOptions.value)
      runner.run(
        "net.minecraftforge.fml.relauncher.ServerLaunchWrapper",
        (fullClasspath in ForgeRun).value.map(_.data),
        Seq(),
        streams.value.log
      ).get
    },

    forge.cleanCache := IO.delete(forge.cacheRoot.value),
    cleanKeepFiles ++= (if(forge.cleanLtCache.value) Seq() else Seq(forge.ltCacheDir.value)),
    cleanFiles ++= (if(forge.cleanRunDir.value) Seq(forge.cacheRoot.value, forge.runDir.value)
                    else                        Seq(forge.cacheRoot.value))
  )
}

object ForgePlugin_1_12 extends AutoPlugin {
  override def requires = BaseForgePlugin

  import BaseForgePlugin.autoImport._

  override def projectSettings = Seq(
    forge.mcBaseVersion := "1.12",
    forge.mcVersion     := "1.12.2",
    forge.version       := "14.23.4.2759",
    forge.mappings      := "stable_39",

    forge.scalaVersion  := "2.11.1",
    lwjgl.version       := "2.9.4-nightly-20150209",

    forge.excludedOrganizations := Set("org.scala-lang", "org.scala-lang.modules", "org.lwjgl.lwjgl"),
    forge.excludedOrganizations in ForgeRun := Set("org.lwjgl.lwjgl"),
    forge.excludedOrganizations in ForgeBuild := Set("org.lwjgl.lwjgl"),
    forge.serverDepPrefixes := Seq(
      "org/bouncycastle/", "org/apache/", "com/google/", "com/mojang/authlib/", "com/mojang/util/",
      "gnu/trove/", "io/netty/", "javax/annotation/", "argo/", "it/"
    )
  )
}